<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenMesh: Using (custom) properties</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="logo_align.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="rwth_vci_rgb.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenMesh
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a04090.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Using (custom) properties </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This examples shows:</p>
<ul>
<li>How to add and remove custom properties</li>
<li>How to get and set the value of a custom property</li>
</ul>
<p>In the last example we computed the barycenter of each vertex' neighborhood and stored it in an array. It would be more convenient and less error-prone if we could store this data in the mesh and let OpenMesh manage the data. It would be even more helpful if we could attach such properties dynamically to the mesh.</p>
<p>Custom properties can be conveniently created and attached to meshes with the following functions:</p><ul>
<li><a class="el" href="a02397.html#a879b7250e5270fbaee884ec1e0af0a4f">makeTemporaryProperty()</a> creates a property that is temporary to the current scope.</li>
<li><a class="el" href="a02397.html#a6532b67cfcf20a1a0754651f26b7179f">getOrMakeProperty()</a> is used for creating and accessing permanent named properties on a mesh.</li>
<li><a class="el" href="a02397.html#a28070d2a453498769b94d57953420785">getProperty()</a> is used for accessing an existing permanent named property on a mesh.</li>
</ul>
<p>All three functions take two template arguments:</p><ul>
<li>First, the type of the mesh element that the property is attached to (i.e. <a class="el" href="a02193.html" title="Handle for a vertex entity. ">OpenMesh::VertexHandle</a>, <a class="el" href="a02197.html" title="Handle for a halfedge entity. ">OpenMesh::HalfedgeHandle</a>, <a class="el" href="a02201.html" title="Handle for a edge entity. ">OpenMesh::EdgeHandle</a>, or <a class="el" href="a02205.html" title="Handle for a face entity. ">OpenMesh::FaceHandle</a>).</li>
<li>Second, the type of the property value that is attached to each element (e.g., <code>int</code>, <code>double</code>, etc.).</li>
</ul>
<p>All three functions return a handle object (of type <a class="el" href="a02397.html" title="This class is intended to manage the lifecycle of properties. ">OpenMesh::PropertyManager</a>) that manages the lifetime of the property and provides read / write access to its values.</p>
<p>In this example, we will store the <code>cog</code> value (see previous example) in a vertex property instead of keeping it in a separate array. To do so, we first add a (temporary) property of the desired element type (<a class="el" href="a02193.html" title="Handle for a vertex entity. ">OpenMesh::VertexHandle</a>) and value type (<code>MyMesh::Point</code>) to the mesh:</p>
 <div class="fragment"><div class="line">      <span class="keyword">auto</span> cog = OpenMesh::makeTemporaryProperty&lt;OpenMesh::VertexHandle, MyMesh::Point&gt;(mesh);</div></div><!-- fragment --></p>
<p>Enough memory is allocated to hold as many values of <code>MyMesh::Point</code> as there are vertices. All insert and delete operations on the mesh are synchronized with the attached properties.</p>
<p>Once the property is created, we can use it to compute the centers of the neighborhood of each vertex:</p>
<p><div class="fragment"><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; vh : mesh.vertices()) {</div><div class="line">              cog[vh] = {0,0,0};</div><div class="line">              <span class="keywordtype">int</span> valence = 0;</div><div class="line">              <span class="comment">// Iterate over all 1-ring vertices around vh</span></div><div class="line">              <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; vvh : mesh.vv_range(vh)) {</div><div class="line">                  cog[vh] += mesh.point(vvh);</div><div class="line">                  ++valence;</div><div class="line">              }</div><div class="line">              cog[vh] /= valence;</div><div class="line">          }</div></div><!-- fragment --></p>
<p>Finally, we set the new position for each vertex:</p>
<p><div class="fragment"><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; vh : mesh.vertices()) {</div><div class="line">              mesh.point(vh) = cog[vh];</div><div class="line">          }</div></div><!-- fragment --> </p><hr/>
<p>Since we chose to use <a class="el" href="a02397.html#a879b7250e5270fbaee884ec1e0af0a4f">makeTemporaryProperty()</a>, the created property is automatically removed from the mesh as soon as we leave the scope of the associated handle variable <code>cog</code>.</p>
<p>If, instead, a property is desired to survive its local scope, it should be created with using <a class="el" href="a02397.html#a6532b67cfcf20a1a0754651f26b7179f">getOrMakeProperty()</a>. In that case, the property must be given a name that can later be used to retrieve the property. For example:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> face_area = OpenMesh::makeTemporaryProperty&lt;OpenMesh::FaceHandle, double&gt;(mesh, <span class="stringliteral">&#39;face_area&#39;</span>);</div></div><!-- fragment --><p>At a later time, we can use the <a class="el" href="a02397.html#a28070d2a453498769b94d57953420785">getProperty()</a> function to obtain a handle to a property that was previously created by refering to its name: </p><div class="fragment"><div class="line"><span class="keywordflow">try</span> {</div><div class="line">    <span class="keyword">auto</span> face_area = OpenMesh::getProperty&lt;OpenMesh::FaceHandle, double&gt;(mesh, <span class="stringliteral">&#39;face_area&#39;</span>);</div><div class="line">    <span class="comment">// Use the face_area property.</span></div><div class="line">}</div><div class="line"><span class="keywordflow">catch</span> (<span class="keyword">const</span> std::runtime_error&amp; e) {</div><div class="line">    <span class="comment">// Property not found. Handle the error here.</span></div><div class="line">}</div></div><!-- fragment --> <hr/>
<p>The functions <a class="el" href="a02397.html#a879b7250e5270fbaee884ec1e0af0a4f">makeTemporaryProperty()</a>, <a class="el" href="a02397.html#a6532b67cfcf20a1a0754651f26b7179f">getOrMakeProperty()</a>, and <a class="el" href="a02397.html#a28070d2a453498769b94d57953420785">getProperty()</a> are the convenient high-level interface for creating and accessing mesh properties.</p>
<p>Beneath these convenience functions, there is also a low-level property interface where handle and property lifetime must be managed manually. This interface is accessed through a mesh's add_property(), remove_property(), and property() functions and several property handle classes (<a class="el" href="a02373.html" title="Handle representing a vertex property. ">OpenMesh::VPropHandleT</a>, <a class="el" href="a02377.html" title="Handle representing a halfedge property. ">OpenMesh::HPropHandleT</a>, <a class="el" href="a02381.html" title="Handle representing an edge property. ">OpenMesh::EPropHandleT</a>, <a class="el" href="a02385.html" title="Handle representing a face property. ">OpenMesh::FPropHandleT</a>, <a class="el" href="a02389.html" title="Handle representing a mesh property. ">OpenMesh::MPropHandleT</a>). </p><hr/>
<p>Below is the complete source code:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;OpenMesh/Core/IO/MeshIO.hh&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;OpenMesh/Core/Mesh/TriMesh_ArrayKernelT.hh&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;OpenMesh/Core/Utils/PropertyManager.hh&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> MyMesh = <a class="code" href="a02261.html">OpenMesh::TriMesh_ArrayKernelT&lt;&gt;</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">    <span class="comment">// Read command line options</span></div><div class="line">    MyMesh mesh;</div><div class="line">    <span class="keywordflow">if</span> (argc != 4) {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Usage: &quot;</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">&quot; #iterations infile outfile&quot;</span> &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> iterations = argv[1];</div><div class="line">    <span class="keyword">const</span> std::string infile = argv[2];</div><div class="line">    <span class="keyword">const</span> std::string outfile = argv[3];</div><div class="line">    </div><div class="line">    <span class="comment">// Read mesh file</span></div><div class="line">    <span class="keywordflow">if</span> (!<a class="code" href="a01203.html#ac417960ec28ffdd7e7003a2b1ebb2d1c">OpenMesh::IO::read_mesh</a>(mesh, infile)) {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: Cannot read mesh from &quot;</span> &lt;&lt; infile &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      <span class="comment">// Add a vertex property storing the computed centers of gravity</span></div><div class="line">      <span class="keyword">auto</span> cog = OpenMesh::makeTemporaryProperty&lt;OpenMesh::VertexHandle, MyMesh::Point&gt;(mesh);</div><div class="line"></div><div class="line">      <span class="comment">// Smooth the mesh several times</span></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; iterations; ++i) {</div><div class="line">          <span class="comment">// Iterate over all vertices to compute centers of gravity</span></div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; vh : mesh.vertices()) {</div><div class="line">              cog[vh] = {0,0,0};</div><div class="line">              <span class="keywordtype">int</span> valence = 0;</div><div class="line">              <span class="comment">// Iterate over all 1-ring vertices around vh</span></div><div class="line">              <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; vvh : mesh.vv_range(vh)) {</div><div class="line">                  cog[vh] += mesh.point(vvh);</div><div class="line">                  ++valence;</div><div class="line">              }</div><div class="line">              cog[vh] /= valence;</div><div class="line">          }</div><div class="line">          <span class="comment">// Move all vertices to the previously computed positions</span></div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; vh : mesh.vertices()) {</div><div class="line">              mesh.point(vh) = cog[vh];</div><div class="line">          }</div><div class="line">      }</div><div class="line">    } <span class="comment">// The cog vertex property is removed from the mesh at the end of this scope</span></div><div class="line">    </div><div class="line">    <span class="comment">// Write mesh file</span></div><div class="line">    <span class="keywordflow">if</span> (!<a class="code" href="a01203.html#ac417960ec28ffdd7e7003a2b1ebb2d1c">OpenMesh::IO::read_mesh</a>(mesh, outfile)) {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: Cannot write mesh to &quot;</span> &lt;&lt; outfile &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<hr>
<address>
<small>
<a href="http://www.rwth-graphics.de" style="text-decoration:none;">
</a>
Project <b>OpenMesh</b>, 
&copy;&nbsp; Computer Graphics Group, RWTH Aachen.
Documentation generated using 
<a class="el" href="http://www.doxygen.org/index.html">
<b>doxygen</b>
</a>.
</small>
</address>
</body>
</html>
